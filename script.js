/**
 * Существует множество типов нейронов.
 * Наша сеть использует нейрон с сигмоидной функцией активации,
 * которая принимает любое число и трансформирует его в значение, лежащее в диапазоне от 0 до 1.
 */

// Деструктуризируем Layer и Network из библиотеки
const { Layer, Network } = window.synaptic;

/**
 * Создаем слои при помощи функции new Layer в synaptic.
 * Число в скобках определяет, сколько каждый слой должен содержать нейронов.
 */
var inputLayer = new Layer(2);
var hiddenLayer = new Layer(3);
var outputLayer = new Layer(1);

// Далее соединяем эти слои вместе и создаем экземпляр новой сети.
inputLayer.project(hiddenLayer);
hiddenLayer.project(outputLayer);

var myNetwork = new Network({
    input: inputLayer,
    hidden: [hiddenLayer],
    output: outputLayer,
});

// Обучение нашей сети
var learningRate = 0.3;

/**
 * Запускаем сеть 20 000 раз.
 * Каждый раз распространяемся в прямом и обратном направлении четыре раза,
 * проходя через четыре возможных входа для этой сети: [0,0], [0,1], [1,0], [1,1].
 */
for (var i = 0; i < 20000; i++) {
    /**
     * Начинаем с команды myNetwork.activate([0,0]), где [0,0] — данные, которые посылаются в сеть.
     * Это прямое распространение, которое также называется активизацией сети.
     * 0,0 => 0
     */
    myNetwork.activate([0, 0]);
    /**
     * После каждого прямого распространения требуется сделать и обратное,
     * тогда сеть обновит свои веса и свдиг.
     * Обратное распротстранение осуществляется командой myNetwork.propagate(learningRate, [0]).
     * Параметр learningRate — константа, которая говорит сети, насколько каждый раз нужно изменять веса.
     * Второй параметр — 0 представляет корректный ответ для заданного входа [0,0].
     */
    myNetwork.propagate(learningRate, [0]);

    // 0,1 => 1
    myNetwork.activate([0, 1]);
    myNetwork.propagate(learningRate, [1]);

    // 1,0 => 1
    myNetwork.activate([1, 0]);
    myNetwork.propagate(learningRate, [1]);

    // 1,1 => 0
    myNetwork.activate([1, 1]);
    myNetwork.propagate(learningRate, [0]);
}

/**
 * Далее сеть сравнивает свое предсказание с правильной меткой.
 * На этом шаге определяется, было ли предсказание сделано правильно.
 * Сеть использует сравнение в качестве базиса для корректировки значений весов и сдвига.
 * Поэтому в следующий раз предсказание будет немного точнее.
 * После выполнения 20 000 итераций в цикле for мы можем посмотреть, насколько хорошо обучилась сеть,
 * при помощи активизации сети со всеми четырьмя возможными входами:
 */
console.log(myNetwork.activate([0, 0])); // [0.015020775950893527]
console.log(myNetwork.activate([0, 1])); // [0.9815816381088985]
console.log(myNetwork.activate([1, 0])); // [0.9871822457132193]
console.log(myNetwork.activate([1, 1])); // [0.012950087641929467]

/**
 * Если округлить эти значения до ближайшего целого числа,
 * получим корректные ответы для XOR операций.
 */
